# 再保分入和分出 - 首月计量月份及利率曲线选取逻辑分析

## 一、再保分入 (Reinsurance Inward) 

### 1.1 首月计量月份的确定

**代码位置**: `core/calculations/reinsurance_calculator.py` 第214-248行

**逻辑流程**:

```python
# 步骤1: 获取初始确认日 (ini_confirm)
first_ini_confirm_date = all_measure_records_df['ini_confirm'].iloc[0]
ini_confirm_date_parsed = pd.to_datetime(first_ini_confirm_date)

# 步骤2: 获取确认日期 (confirm_date)
confirm_date_parsed = pd.to_datetime(confirm_date)

# 步骤3: 确定初始计量日期 (取孰晚值)
effective_start_date = max(confirm_date_parsed, ini_confirm_date_parsed)
initial_measure_month = effective_start_date.strftime('%Y%m')
```

**关键逻辑**:
- ✅ **初始计量日期** = `max(confirm_date, ini_confirm)` (取孰晚值)
- ✅ **首月计量月份** = 初始计量日期所在月份
- ✅ **计算时间轴** 从首月计量月份开始，逐月计算到评估月份

**示例**:
```
confirm_date = 2024-12-15
ini_confirm = 2024-12-20
→ effective_start_date = 2024-12-20 (取孰晚)
→ initial_measure_month = 202412

confirm_date = 2025-01-05
ini_confirm = 2024-12-20
→ effective_start_date = 2025-01-05 (取孰晚)
→ initial_measure_month = 202501
```

---

### 1.2 利率曲线选取逻辑

**代码位置**: `core/calculations/reinsurance_calculator.py` 第230-237行, 第287-295行, 第343-372行

#### 1.2.1 利率曲线锁定月份

```python
# 利率曲线仍使用原始 ini_confirm 的月份
ini_confirm_month = ini_confirm_date_parsed.strftime('%Y%m')

# 锁定利率曲线
locked_in_rate_curve = discount_rates_map.get(ini_confirm_month)
```

**关键逻辑**:
- ✅ **利率曲线锁定月份** = `ini_confirm` 所在月份（**原始值，不取孰晚**）
- ✅ **利率曲线在整个计算过程中保持不变**，锁定在 `ini_confirm_month`

#### 1.2.2 利率曲线使用规则

**用于 IFIE (未到期利息) 计算**:
```python
# 在逐月计算循环中 (第343-351行)
term_month = month_counter  # 从1开始递增
non_onerous_rate_float = locked_in_rate_curve.get(term_month)
```

**规则**:
- ✅ 使用 **锁定的利率曲线** (`locked_in_rate_curve`)
- ✅ 根据 **term_month** (第几个月) 从曲线中取对应期数的利率
- ✅ `term_month = month_counter` (从1开始，逐月递增)

**用于亏损测试 (Onerous Test)**:
```python
# 使用当前评估月的利率曲线
onerous_rate_curve = discount_rates_map.get(val_month, {})
```

**规则**:
- ✅ 使用 **当前评估月份** (`val_month`) 的利率曲线
- ✅ 每个评估月使用当月的利率曲线进行亏损测试

**示例**:
```
ini_confirm = 2024-12-20
→ ini_confirm_month = 202412
→ 锁定利率曲线: 202412月的利率曲线

计算月份: 202412 (month_counter=1)
→ 使用 202412利率曲线的第1期利率

计算月份: 202501 (month_counter=2)
→ 使用 202412利率曲线的第2期利率 (仍锁定)

计算月份: 202502 (month_counter=3)
→ 使用 202412利率曲线的第3期利率 (仍锁定)

亏损测试 (202502):
→ 使用 202502月的利率曲线 (当前评估月)
```

---

## 二、再保分出 (Reinsurance Outward)

### 2.1 首月计量月份的确定

**代码位置**: `core/calculations/reinsurance_outward_calculator.py` 第286-353行

**逻辑流程**:

```python
# 步骤1: 获取初始确认日 (ini_confirm)
ini_confirm = static_data.get('ini_confirm')
ini_confirm_parsed = pd.to_datetime(ini_confirm)

# 步骤2: 获取签单日期
is_certi_no_empty = (certi_no is None or certi_no == '' or ...)

if is_certi_no_empty:
    # 原保单：使用签单日期 (under_write_date)
    sign_date = under_write_date
else:
    # 批单：使用批单签单日期 (certi_write_date)
    sign_date = certi_write_date

sign_date_parsed = pd.to_datetime(sign_date)

# 步骤3: 确定初始计量日期 (取孰晚值)
effective_start_date = max(sign_date_parsed, ini_confirm_parsed)
initial_booking_month = effective_start_date.strftime('%Y%m')
```

**关键逻辑**:
- ✅ **签单日期选择**:
  - 如果 `certi_no` 为空 → 使用 `under_write_date` (原保单签单日期)
  - 如果 `certi_no` 不为空 → 使用 `certi_write_date` (批单签单日期)
- ✅ **初始计量日期** = `max(签单日期, ini_confirm)` (取孰晚值)
- ✅ **首月计量月份** = 初始计量日期所在月份
- ✅ **计算时间轴** 从首月计量月份开始，逐月计算到评估月份

**示例**:
```
原保单 (certi_no为空):
under_write_date = 2024-12-15
ini_confirm = 2024-12-20
→ effective_start_date = 2024-12-20 (取孰晚)
→ initial_booking_month = 202412

批单 (certi_no不为空):
certi_write_date = 2025-01-10
ini_confirm = 2024-12-20
→ effective_start_date = 2025-01-10 (取孰晚)
→ initial_booking_month = 202501
```

---

### 2.2 利率曲线选取逻辑

**代码位置**: `core/calculations/reinsurance_outward_calculator.py` 第355-382行, 第36-125行

#### 2.2.1 利率曲线锁定月份

```python
# 利率曲线仍使用原始 ini_confirm 的月份，而不是孰晚后的日期
original_ini_confirm_month = ini_confirm_parsed.strftime('%Y%m')
locked_in_rate_curve = discount_rates_map.get(original_ini_confirm_month)
```

**关键逻辑**:
- ✅ **利率曲线锁定月份** = `ini_confirm` 所在月份（**原始值，不取孰晚**）
- ✅ **利率曲线在整个计算过程中保持不变**，锁定在 `original_ini_confirm_month`

#### 2.2.2 利率曲线使用规则

**用于 IFIE (未到期利息) 计算**:
```python
# 在逐月计算循环中
term_month = month_counter  # 从1开始递增
non_onerous_rate_float = non_onerous_rate_curve.get(term_month)
```

**规则**:
- ✅ 使用 **锁定的利率曲线** (`non_onerous_rate_curve`)
- ✅ 根据 **term_month** (第几个月) 从曲线中取对应期数的利率
- ✅ `term_month = month_counter` (从1开始，逐月递增)

**示例**:
```
ini_confirm = 2024-12-20
→ original_ini_confirm_month = 202412
→ 锁定利率曲线: 202412月的利率曲线

计算月份: 202412 (month_counter=1)
→ 使用 202412利率曲线的第1期利率

计算月份: 202501 (month_counter=2)
→ 使用 202412利率曲线的第2期利率 (仍锁定)

计算月份: 202502 (month_counter=3)
→ 使用 202412利率曲线的第3期利率 (仍锁定)
```

---

## 三、对比总结

| 项目 | 再保分入 | 再保分出 |
|------|---------|---------|
| **首月计量日期判断依据** | `confirm_date` vs `ini_confirm` | `签单日期` vs `ini_confirm` |
| **签单日期来源** | 无（使用confirm_date） | 原保单：`under_write_date`<br>批单：`certi_write_date` |
| **首月计量日期规则** | `max(confirm_date, ini_confirm)` | `max(签单日期, ini_confirm)` |
| **利率曲线锁定月份** | `ini_confirm` 所在月份 | `ini_confirm` 所在月份 |
| **利率曲线锁定时机** | 计算开始前锁定 | 计算开始前锁定 |
| **IFIE利率选取** | 锁定曲线的第`term_month`期 | 锁定曲线的第`term_month`期 |
| **term_month递增规则** | `month_counter` (从1开始) | `month_counter` (从1开始) |
| **亏损测试利率** | 使用当前评估月的利率曲线 | 使用当前评估月的利率曲线 |

---

## 四、关键区别点

### 4.1 首月计量月份判断依据不同

- **再保分入**: 使用 `confirm_date`（确认日期）
- **再保分出**: 使用 `签单日期`（根据是否为批单选择不同的字段）

### 4.2 共同点

1. ✅ 都使用 **孰晚原则** 确定首月计量日期
2. ✅ 都使用 **原始 `ini_confirm` 月份** 锁定利率曲线（不取孰晚）
3. ✅ 利率曲线在整个计算周期内保持不变
4. ✅ IFIE计算使用锁定曲线的第`term_month`期利率
5. ✅ 亏损测试使用当前评估月的利率曲线

---

## 五、代码引用

### 再保分入关键代码段

```217:237:core/calculations/reinsurance_calculator.py
        # 获取初始确认日
        first_ini_confirm_date = all_measure_records_df['ini_confirm'].iloc[0]
        if pd.isna(first_ini_confirm_date):
            raise ValueError("'ini_confirm' date is missing from the measurement records.")
        
        # 获取确认日期并转换为日期对象
        confirm_date_parsed = pd.to_datetime(confirm_date)
        ini_confirm_date_parsed = pd.to_datetime(first_ini_confirm_date)
        
        # 初始计量日期取 confirm_date 与 ini_confirm 的孰晚值
        effective_start_date = max(confirm_date_parsed, ini_confirm_date_parsed)
        initial_measure_month = effective_start_date.strftime('%Y%m')
        
        # 利率曲线仍使用原始 ini_confirm 的月份
        ini_confirm_month = ini_confirm_date_parsed.strftime('%Y%m')
        
        main_logs.write(f"  - 确认日期 (confirm_date): {confirm_date_parsed.strftime('%Y-%m-%d')}\n")
        main_logs.write(f"  - 初始确认日 (ini_confirm): {ini_confirm_date_parsed.strftime('%Y-%m-%d')}\n")
        main_logs.write(f"  - 初始计量日期 (取孰晚): {effective_start_date.strftime('%Y-%m-%d')}\n")
        main_logs.write(f"  - 初始计量月: {initial_measure_month}\n")
        main_logs.write(f"  - 利率曲线锁定月 (使用原始ini_confirm): {ini_confirm_month}\n")
```

### 再保分出关键代码段

```286:337:core/calculations/reinsurance_outward_calculator.py
        # --- NEW LOGIC: Determine the effective start month ---
        ini_confirm = static_data.get('ini_confirm')
        if pd.isna(ini_confirm):
            raise ValueError("'ini_confirm' is missing and cannot determine start month.")
        
        # 获取签单日期：原保单用 under_write_date，批单用 certi_write_date
        # 优先从 static_data 获取，如果没有则从历史记录中获取
        under_write_date = static_data.get('under_write_date')
        certi_write_date = static_data.get('certi_write_date')
        
        # 如果 static_data 中没有，尝试从历史记录中获取
        if (pd.isna(under_write_date) or under_write_date is None or under_write_date == '') and not all_measure_records_df.empty:
            if 'under_write_date' in all_measure_records_df.columns:
                under_write_date = all_measure_records_df['under_write_date'].iloc[0]
        if (pd.isna(certi_write_date) or certi_write_date is None or certi_write_date == '') and not all_measure_records_df.empty:
            if 'certi_write_date' in all_measure_records_df.columns:
                certi_write_date = all_measure_records_df['certi_write_date'].iloc[0]
        
        # 根据 certi_no 判断使用哪个签单日期
        # certi_no 为空或 NULL 表示原保单，使用 under_write_date；否则使用 certi_write_date
        is_certi_no_empty = (certi_no is None or 
                            certi_no == '' or 
                            str(certi_no).strip().upper() in ['NA', 'N/A', 'NULL', 'NONE'])
        
        if is_certi_no_empty:
            # 原保单：使用签单日期 (under_write_date)
            sign_date = under_write_date
            sign_date_type = "签单日期 (under_write_date)"
        else:
            # 批单：使用批单签单日期 (certi_write_date)
            sign_date = certi_write_date
            sign_date_type = "批单签单日期 (certi_write_date)"
        
        if pd.isna(sign_date) or sign_date is None or sign_date == '':
            raise ValueError(f"无法获取签单日期：{sign_date_type} 为空。")
        
        # 处理日期格式：如果是字符串格式 'YYYYMMDD'，需要转换为日期对象
        # 初始计量日期取签单日期与 ini_confirm 的孰晚值
        if isinstance(sign_date, str) and len(sign_date) == 8 and sign_date.isdigit():
            # 格式为 'YYYYMMDD'，需要转换
            sign_date_parsed = pd.to_datetime(sign_date, format='%Y%m%d')
        else:
            sign_date_parsed = pd.to_datetime(sign_date)
        ini_confirm_parsed = pd.to_datetime(ini_confirm)
        effective_start_date = max(sign_date_parsed, ini_confirm_parsed)
        initial_booking_month = effective_start_date.strftime('%Y%m')
        
        main_logs.write(f"  - 批单号 (certi_no): {certi_no if not is_certi_no_empty else '(空-原保单)'}\n")
        main_logs.write(f"  - {sign_date_type}: {sign_date_parsed.strftime('%Y-%m-%d')}\n")
        main_logs.write(f"  - 初始确认日 (ini_confirm): {ini_confirm_parsed.strftime('%Y-%m-%d')}\n")
        main_logs.write(f"  - 初始计量日期 (取孰晚): {effective_start_date.strftime('%Y-%m-%d')}\n")
        main_logs.write(f"  - 初始计量月: {initial_booking_month}\n")
```

---

## 六、总结

### 核心要点

1. **首月计量月份**: 两个模块都使用孰晚原则，但判断依据不同
   - 再保分入：`confirm_date` vs `ini_confirm`
   - 再保分出：`签单日期` vs `ini_confirm`

2. **利率曲线锁定**: 两个模块逻辑完全一致
   - 都使用 **原始 `ini_confirm` 月份** 锁定利率曲线
   - 在整个计算周期内保持不变
   - 根据 `term_month` (月份序号) 从锁定曲线中取对应期数利率

3. **利率曲线使用**: 
   - **IFIE计算**: 使用锁定的利率曲线
   - **亏损测试**: 使用当前评估月的利率曲线

